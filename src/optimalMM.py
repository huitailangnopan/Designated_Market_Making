from src.order import Order
import random
import numpy as np


class marketmarker:
    def __init__(self, ids, rebaterate=-0.0020):
        """
        Initialize the marketmarker class with default parameters.
        """
        self.tickers = None
        self.current_time = 0
        self.orders = []
        self.prev_price = []
        self.prev_all_orders = []
        self.prev_order = []
        self.inventory = 0
        self.inventory_history = []
        self.asset = "IBM"
        self.max_tolerance = 500
        self.cash = 100
        self.cash_history = []
        self.id = ids
        self.mid_price_collecton = []
        self.rebate_rate = rebaterate

    def update_time(self, current_time):
        """
        Update the current time.

        Parameters:
        current_time (int): The new current time.
        """
        self.current_time = current_time

    def update_tickers(self, tickers):
        """
        Update the tickers.

        Parameters:
        tickers (list): The new list of tickers.
        """
        self.tickers = tickers

    def receive_matched_orders(self, matched_orders):
        """
        Update the inventory based on the feedback.

        Parameters:
        feedback (list): The feedback received.
        """
        self.update_inventory(matched_orders)

    def receive_unsettled_trades(self, orders):
        """
        Receive all the orders.

        Parameters:
        orders (list): The list of orders.
        """
        self.prev_all_orders = orders

    def general_update(self, matched_orders, all_orders, tickers, time):
        """
        Perform a general update of tickers, time, and inventory based on feedback.

        Parameters:
        feedback (list): The feedback received.
        tickers (list): The new list of tickers.
        time (int): The new current time.
        """
        self.receive_matched_orders(matched_orders)
        self.receive_unsettled_trades(all_orders)
        self.update_tickers(tickers)
        self.update_time(time)


    def update_inventory(self, matched):
        """
        Update the inventory and cash based on the matched orders.

        Parameters:
        matched (list): The list of matched orders.
        """
        for i in matched:
            if i["Buyer"] == self.id:
                self.inventory += i["Matched Quantity"]
                self.cash -= i["Matched Quantity"] * i["Matched Price"] + i["Matched Quantity"] * i["Matched Price"] * self.rebate_rate
            elif i["Seller"] == self.id:
                self.inventory -= i["Matched Quantity"]
                self.cash += i["Matched Quantity"] * i["Matched Price"] + i["Matched Quantity"] * i["Matched Price"] * self.rebate_rate
        self.inventory_history.append(self.inventory)
        self.cash_history.append(self.cash)

    def trading_strategy(self):
        """
        Implement the trading strategy based on the current time, latest orderbook, and market maker number.

        Parameters:
        current_time (int): The current time.
        latest_orderbook (list): The latest orderbook.
        mm_no (int): The market maker number.

        Returns:
        list: The list of orders generated by the trading strategy.
        """
        mm_no = self.id
        latest_orderbook = self.prev_all_orders
        current_time = self.current_time
        myorder = []
        orderbook = {}
        orderbook["ask_prices"] = []
        orderbook["bid_prices"] = []
        orderbook["ask_quantity"] = []
        orderbook['bid_quantity'] = []
        asset = self.asset
        for i in latest_orderbook:
            if i.getordertype() == "SELL" and i.getcustomerid() <= 0:
                orderbook["ask_prices"].append(i.getorderprice())
                orderbook["ask_quantity"].append(i.getorderquantity())
            if i.getordertype() == "BUY" and i.getcustomerid() <= 0:
                orderbook["bid_prices"].append(i.getorderprice())
                orderbook["bid_quantity"].append(i.getorderquantity())
        if sum(orderbook['ask_quantity']) + sum(orderbook['bid_quantity']) != 0:
            mid_price = (np.dot(orderbook["bid_prices"], orderbook["bid_quantity"]) + np.dot(orderbook["ask_prices"], orderbook["ask_quantity"])) / (sum(orderbook['ask_quantity']) + sum(orderbook['bid_quantity']))
            self.mid_price_collecton.append(mid_price)
            s = mid_price  # Current mid-price
            q = self.inventory/self.max_tolerance  # Dealer's inventory percentage
            sigma_squared = (np.std(self.mid_price_collecton) if len(self.mid_price_collecton)<20 else np.std(self.mid_price_collecton[-20:]))**2  # Volatility squared
            # sigma_squared = (np.std(self.mid_price_collecton) if len(self.mid_price_collecton) < 20 else np.std(
            #     self.mid_price_collecton[-20:]))
            pmax = max(self.mid_price_collecton) if len(self.mid_price_collecton)<20 else max(self.mid_price_collecton[-20:])
            pmin = min(self.mid_price_collecton) if len(self.mid_price_collecton)<20 else min(self.mid_price_collecton[-20:])
            target_weight = (pmax - s) / (pmax - pmin) if pmax>pmin else 0.5 # Target weight
            # Calculate the target inventory (I_t)
            I_t = self.max_tolerance * target_weight
            # Calculate the time horizon (T - t), here's one timestamp
            time_horizon = 1
            # Calculate the reservation ask price (r_a)
            r_a = s + (1 - 2 * q) * (sigma_squared / 2) * time_horizon
            #r_a = s + (1 - 2 * q)
            r_a = r_a * (1 + self.rebate_rate)
            # Calculate the reservation bid price (r_b)
            r_b = s + (-1 - 2 * q) * (sigma_squared / 2) * time_horizon
            #r_b = s + (-1 - 2 * q)
            r_b = r_b * (1 - self.rebate_rate)
            # Calculate the reservation ask quantity (q_a)
            q_a = max(I_t + self.inventory,1)/5

            # Calculate the reservation bid quantity (q_b)
            q_b = max(I_t - self.inventory,1)/5
            #print("s:", s, "r_a: ", r_a, "r_b: ", r_b, "q_a: ", q_a, "q_b: ", q_b,'q:',q,'sigma_squared:',sigma_squared)
            if q_a > 5:
                for i in range(5):
                    ask_price = round(r_a + i * 0.1, 2)
                    ask_quantity = int(q_a/5)
                    myorder.append(self.generate_marketorder(current_time, asset, "SELL", ask_price, ask_quantity, mm_no))
            elif q_a > 0:
                ask_price = round(r_a, 2)
                ask_quantity = int(q_a)
                myorder.append(self.generate_marketorder(current_time, asset, "SELL", ask_price, ask_quantity, mm_no))
            if q_b > 5:
                for i in range(5):
                    bid_price = round(r_b - i * 0.1, 2)
                    bid_quantity = int(q_b/5)
                    myorder.append(self.generate_marketorder(current_time, asset, "BUY", bid_price, bid_quantity, mm_no))
            elif q_b > 0:
                bid_price = round(r_b, 2)
                bid_quantity = int(q_b)
                myorder.append(self.generate_marketorder(current_time, asset, "BUY", bid_price, bid_quantity, mm_no))
        return myorder

    def generate_marketorder(self, current_time, asset, order_type, order_price, order_quantity, mm_no):
        """
        Generate a market order.

        Parameters:
        current_time (int): The current time.
        asset (str): The asset for the order.
        order_type (str): The type of the order ('BUY' or 'SELL').
        order_price (float): The price of the order.
        order_quantity (int): The quantity of the order.
        mm_no (int): The market maker number.

        Returns:
        Order: The generated market order.
        """
        order_id = str(current_time) + str(asset) + str(random.randint(0, 100))
        customer_id = mm_no
        order_time = current_time
        return Order(order_id, customer_id, order_time, asset, order_type, order_price, order_quantity)



"""
    def trading_strategy(self, current_time, latest_orderbook):

        mm_no = self.id
        myorder = []
        orderbook = {}
        orderbook["ask_prices"] = []
        orderbook["bid_prices"] = []
        orderbook["ask_quantity"] = []
        orderbook['bid_quantity'] = []
        asset = self.asset
        for i in latest_orderbook:
            if i.getordertype() == "SELL":
                orderbook["ask_prices"].append(i.getorderprice())
                orderbook["ask_quantity"].append(i.getorderquantity())
            if i.getordertype() == "BUY":
                orderbook["bid_prices"].append(i.getorderprice())
                orderbook["bid_quantity"].append(i.getorderquantity())
        if len(orderbook['ask_quantity']) + len(orderbook['bid_quantity']) != 0:
            possible_addon = 0
            mid_price = (sum(orderbook["bid_prices"]) + sum(orderbook["ask_prices"])) / (
                        len(orderbook['ask_quantity']) + len(orderbook['bid_quantity']))
            for i in range(len(orderbook['ask_prices'])):
                bid_price = orderbook['ask_prices'][i]
                bid_quantity = orderbook['ask_quantity'][i]
                if bid_quantity + possible_addon + self.inventory < self.max_tolerance and bid_price <= mid_price:
                    myorder.append(
                        self.generate_marketorder(current_time, asset, "BUY", bid_price, bid_quantity, mm_no))
                    possible_addon += bid_quantity
            for i in range(len(orderbook['bid_prices'])):
                ask_price = orderbook['bid_prices'][i]
                ask_quantity = orderbook['bid_quantity'][i]
                if ask_quantity - possible_addon - self.inventory < self.max_tolerance and ask_price >= mid_price:
                    myorder.append(
                        self.generate_marketorder(current_time, asset, "SELL", ask_price, ask_quantity, mm_no))
                    possible_addon -= ask_quantity
            if self.inventory > self.max_tolerance * 0.7:
                sell_quantity = int(self.inventory - self.max_tolerance * 0.7)
                myorder.append(self.generate_marketorder(current_time, asset, "SELL", mid_price, sell_quantity, mm_no))
            if self.inventory < -1 * self.max_tolerance * 0.7:
                buy_quantity = int(-1 * self.inventory - self.max_tolerance * 0.7)
                myorder.append(self.generate_marketorder(current_time, asset, "BUY", mid_price, buy_quantity, mm_no))
        return myorder
"""